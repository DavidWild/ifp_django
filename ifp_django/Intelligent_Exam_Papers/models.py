
import xml.etree.ElementTree as ET
import re
import datetime

from django.db import models
from mptt.models import MPTTModel, TreeForeignKey
from django.contrib.auth.models import User
from easy_thumbnails.fields import ThumbnailerImageField
from taggit.managers import TaggableManager
from django.core.exceptions import ValidationError
from import_export import resources

from Expression import EvalExpression, NoPictureException
from Randoms import RandomGenerator
import definitions


# Create your models here.



class Image(models.Model):
    image = ThumbnailerImageField(upload_to="./", blank=True )
    description = models.TextField(blank=True,null=True)
    createddate = models.DateTimeField(auto_now_add=True,editable=False)
    
    def __unicode__(self):
        return u'%s' % (self.image.name)

    class Meta:
        verbose_name = 'Image and Diagram'
        verbose_name_plural = 'Images and Diagrams'


class PDF_link(models.Model):
    url = models.URLField(unique=True)
    name = models.CharField(max_length=200) # most likely derived from information about the test
    user = models.ForeignKey(User, null=True, blank=True)
    createddate = models.DateTimeField(auto_now_add=True,verbose_name='Date created')

    def __unicode__(self):
        return u'Created on : %s, From Test: %s, Generated by: %s' % (self.createddate, self.name, self.user.username)


    @classmethod
    def create(cls, aurl, aname, auser):
        pdf_link = cls(url=aurl, name=aname, user=auser)
        return pdf_link




    class Meta:
        verbose_name = 'Generated Test PDF'
        verbose_name_plural = 'Generated Test PDFs'
    
class Rubric(models.Model):
    name = models.CharField(blank=False, null=False, unique=True, max_length=50)
    text = models.TextField(verbose_name='Exam board Rubric',unique=False, blank = True, null = False )

    description = models.TextField(blank=True, null=True)
    def __str__(self):
        return self.name

class Meta:
        verbose_name = 'Examination rubric'
        verbose_name_plural = 'Examinations rubrics'

class Board(models.Model):
    name = models.CharField(max_length=50, unique=True )
    logo = models.ForeignKey(Image)

    class Admin:
        pass
    def __str__(self):
        return str(self.name)

    class Meta:
        verbose_name = 'Awarding Body'
        verbose_name_plural = 'Awarding Bodies'
    
class Qualification(models.Model):
    name = models.CharField(max_length=150, unique=True)
    description = models.TextField()
    class Admin:
        pass
    def __str__(self):
        return str(self.name)

    class Meta:
        verbose_name = 'Qualification'
        verbose_name_plural = 'Qualifications'
    
class Subject(models.Model):
    name = models.CharField(max_length=150, unique=True)
    description = models.TextField()
    class Admin:
        pass
    def __str__(self):
        return str(self.name)
    class Meta:
        verbose_name = 'Subject'
        verbose_name_plural = 'Subjects'
    
class Unit(models.Model):
    name = models.CharField(max_length=150, unique=True)
    description = models.TextField()
    class Admin:
        pass
    def __str__(self):
        return str(self.name)

    class Meta:
        verbose_name = 'Unit'
        verbose_name_plural = 'Units'

def validate_content(value):

    pattern = "\$(.*?)\$"
    mathObjects = re.findall(pattern,value)
    print('Mathobjects = ' + str(mathObjects))
    for i in range(0,len(mathObjects)):
        try:
            aGenerator = RandomGenerator()
            aGenerator.EvaluateAll()
            try:
                exp = EvalExpression(mathObjects[i],True,aGenerator)
                #exp.GetLateXMathExpression()
                if exp.syntaxError <> '':
                    print('Expression : ' + exp.ExpressionString + ' has syntax error ' + exp.syntaxError)
                if exp.syntaxError <> '':
                    raise ValidationError(exp.syntaxError)
            except TypeError as e:
                None # caused by not being able to evaluate variables -
                # which we're not interested in as that's checked elsewhere
            except NoPictureException as e:
                None # caused by not having a picture
            except ValueError as e:
                None # caused by surd and other functions not being able to evaluate
        except Exception as e:
            raise ValidationError( str(e) )




def validate_randoms(value):
    try:
        value = definitions.XMLfromRandoms(value)
        root = ET.fromstring('<randoms>' + value + '</randoms>')
    except:
        raise ValidationError("The XML is invalid.  Please check it.")

    try:
        aRandomGenerator = RandomGenerator()
        for randomNode in root.findall('random'):
            aRandomGenerator.AddVariableFromExpressionString(randomNode.get('name'), randomNode.get('expression'),randomNode.get('issystem'))

        aRandomGenerator.AddDependencies()
        aRandomGenerator.PrintDependencies()
        aRandomGenerator.EvaluateAll()
        aRandomGenerator.PrintValues()

    except Exception as e:
        raise ValidationError( str(e) )

    print('Finished Validating Randoms')


class Question(models.Model):
    createddate = models.DateTimeField(verbose_name='Created Date', auto_now_add=True)
    modified_date = models.DateTimeField(verbose_name='Modified Date', auto_now_add=True)

    question_name = models.CharField(blank=False, max_length=50)
    question_text = models.TextField(verbose_name='Question text', blank=True, null=True, validators=[validate_content])
    questions_can_span_pages = models.BooleanField(verbose_name='Question text can span multiple pages', default=False, blank=False, null=False)
    solution_text = models.TextField(verbose_name='Solution text', blank=True, null=True, validators=[validate_content])
    solutions_can_span_pages = models.BooleanField(verbose_name='Solution text can span multiple pages', default=False, blank=False, null=False)

    randoms_text = models.TextField(verbose_name='Random parameters', blank=True, null=True, validators=[validate_randoms])
    questionStaticImages = models.ManyToManyField(Image,related_name='images',blank=True, null=True,verbose_name='Pictures appearing in question')
    pictures_text = models.TextField(verbose_name='Dynamically drawn graphs and diagrams',blank=True, null=True)
    tags = TaggableManager(blank=True)


    class Meta:
        verbose_name = 'Question'
        verbose_name_plural = 'Questions'
    def __str__(self):
        return str(self.question_name )


    def save(self, *args, **kwargs):
        self.modified_date = datetime.datetime.now()
        # try to parse as xml.  If it does then it is old-format text for the randoms

        try:
            if self.randoms_text.startswith('<random'):
                tempText = ''
                TempXML = ET.fromstring('<root>' + self.randoms_text +'</root>')
                for RandomNode in TempXML.findall('random'):
                    tempText = tempText + RandomNode.get('name') + '=' + RandomNode.get('expression') + '\n'
                self.randoms_text = tempText
        except:
            None # just default behaviour


        super(Question, self).save(*args, **kwargs) # Call the "real" save() method.

class Question_Group(MPTTModel):
    name = models.CharField(unique=True, blank=False, null=False, max_length=50)
    createddate = models.DateTimeField(verbose_name ='Created Date', auto_now_add=True)
    modified_date = models.DateTimeField(verbose_name ='Modified Date', auto_now_add=True)
    parent = TreeForeignKey('self', null=True, blank=True, related_name='children')
    description = models.TextField(verbose_name='Description', blank=True, null=True)
    Questions = models.ManyToManyField(Question,verbose_name='Questions in this Question Group',blank=True, null=True)
    tags = TaggableManager(blank=True)
    def __str__(self):
        return str(self.name + ' (' + str(self.Questions.count()) +' questions )' )



class Test(models.Model):

    tags = TaggableManager()
    board = models.ForeignKey(Board)
    
    DevStatus_Choices = (
                         (1, 'In Development'),
                         (2,'In QA'),
                         (3,'Complete')
                        )
    DevStatus = models.IntegerField(verbose_name='Development status', choices=DevStatus_Choices)
    date = models.DateField(verbose_name='Date of the examination')
                            
    qualification = models.ForeignKey(Qualification)
    subject = models.ForeignKey(Subject)

    unit = models.ForeignKey(Unit)
    testXML = models.TextField(verbose_name='XML defining the test ',editable=False)
    QuestionGroup = TreeForeignKey('Question_Group', null=False, blank=False, related_name='Question Group')
    rubric = models.ManyToManyField(Rubric,related_name='Rubrics')
    GeneratedPDFs = models.ManyToManyField(PDF_link,related_name='generated_PDFs',blank=True,verbose_name='Generated Test PDF')

    readonly_fields=('GeneratedPDFs')



    class Meta:
        verbose_name = 'Test'
        verbose_name_plural = 'Tests'

    def __str__(self):
        return 'Board = ' + str(self.board) + ', date = ' + str(self.date) + ', Qualification = ' + str(self.qualification) + ', Subject = ' + str(self.subject) + ', Unit = ' + str(self.unit)




class QuestionResource(resources.ModelResource):

    class Meta:
        model = Question

class TestResource(resources.ModelResource):
    class Meta:
        model = Test

class RubricResource(resources.ModelResource):
    class Meta:
        model = Rubric


class BoardResource(resources.ModelResource):
    class Meta:
        model = Board

class QualificationResource(resources.ModelResource):
    class Meta:
        model = Qualification

class SubjectResource(resources.ModelResource):
    class Meta:
        model = Subject

class UnitResource(resources.ModelResource):
    class Meta:
        model = Unit

class Question_GroupResource(resources.ModelResource):
    class Meta:
        model = Question_Group

class ImageResource(resources.ModelResource):
    class Meta:
        model = Image






class PartBase(MPTTModel):
    Description = models.CharField(max_length=256, blank=True, null=True)
    parent = TreeForeignKey('self', null=True, blank=True, related_name='children')
    MaxMarks = models.FloatField(null=False, blank=False)
    MinMarks = models.FloatField(null=False, blank=False, default=0)
    TotalMarks = models.FloatField(null=False, blank=False, editable=True)
    Part_Text = models.TextField(blank=True, null=True)
    StepsSeenPenalty = models.SmallIntegerField(default=0, null=True, blank=True)
    Question = models.ForeignKey('ScreenQuestion')

    def __str__(self):
        return self.Description


class RandomVariable(models.Model):
    name = models.CharField(max_length=64, blank=False, null=False)
    definition = models.TextField(blank=False, null=False)

    def __str__(self):
        return self.name+'='+self.definition

class ScreenQuestion(models.Model):
    Description = models.CharField(max_length=256, blank=True, null=True)
    part = models.ManyToManyField(PartBase, null=True, blank=True, related_name='question_part')
    createddate = models.DateTimeField(verbose_name ='Created Date', auto_now_add=True)
    modified_date = models.DateTimeField(verbose_name='Modified Date', auto_now_add=True)

    name = models.CharField(blank=False, max_length=50)
    Question_Text = models.TextField(blank=True, null=True)
    DevStatus_Choices = (
                         (1, 'In Development'),
                         (2,'In QA'),
                         (3,'Complete')
                        )
    DevStatus = models.IntegerField(verbose_name='Development status', choices=DevStatus_Choices)
    variable = models.ManyToManyField(RandomVariable, null=True, blank=True)

    def __str__(self):
        return self.Description



class AlgebraAnswer(models.Model):
    text = models.TextField(blank=False, null=False)
    marks = models.DecimalField(blank=False, null=False, decimal_places=2, max_digits=10)
    part = models.ForeignKey('AlgebraPart', null=True, blank=True)
    feedback = models.TextField(blank=True, default='')

class variable(models.Model):
    name = models.CharField(max_length=50)
    domain_start = models.FloatField(default=1)
    domain_end = models.FloatField(default=5)
    domain_step = models.FloatField(default = 0.1)
    failure_rate = models.IntegerField(default = 1)

class AlgebraPart(PartBase):

    answer = models.ManyToManyField(AlgebraAnswer, blank=True, null=True, related_name='algebra_incorrect_answer')

    must_have_strings = models.TextField(blank=True, null=True)
    not_allowed_strings = models.TextField(blank=True, null=False)

    max_fraction_depth = models.IntegerField(null=True, blank=True)
    min_fraction_depth = models.IntegerField(null=True, blank=True)

    max_power_depth = models.IntegerField(null=True, blank=True)
    min_power_depth = models.IntegerField(null=True, blank=True)

    variables = models.ManyToManyField(variable, null=True, blank=True)

class NumberEntryPartAnswer(models.Model):
    answer_from = models.CharField(blank=True, null=True, max_length=128)
    answer_to = models.CharField(blank=True, null=True, max_length=128)
    score = models.DecimalField(blank=True, null=True, max_digits=5, decimal_places=2)
    feedback=models.TextField(blank=True, default='')
    Part = models.ForeignKey('NumberEntryPart')


class NumberEntryPart(PartBase):
    text_before_answer_prompt = models.CharField(blank=True, null=False, default='', max_length=128)
    text_after_answer_prompt = models.CharField(blank=True, null=False, default='', max_length=128)
    accept_account_negatives = models.BooleanField(blank=False,default=True)
    answers = models.ManyToManyField(NumberEntryPartAnswer, null=True, blank=True)

class MultipleChoiceChoice(models.Model):
    Text = models.TextField(blank=True, null=True)
    marks = models.DecimalField(max_digits=5, decimal_places=2)
    Part = models.ForeignKey('MultipleChoicePart')
    feedback = models.TextField(blank=True, default='')

    def __str__(self):
        return self.Text


class MultipleChoicePart(PartBase):
    choices = models.ManyToManyField(MultipleChoiceChoice, null=True, blank=True)


class Author(models.Model):
   name = models.CharField(max_length=100)

class Book(models.Model):
   author = models.ForeignKey(Author)
   title = models.CharField(max_length=100)


